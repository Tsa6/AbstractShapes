<!Doctype HTML>
<!--
Copyright (c) 2017 Taizo 'Tsa6' Simpson
All rights reserved.
Direct inqueries to tsa6games@gmail.com
-->
<html>
    <head>
        <style>
            body {
                overflow: hidden;
            }
            
            canvas {
                position: absolute;
                left: 0;
                top: 0;
            }
        </style>
    </head>
    <body>
        <script src="p5.min.js"></script>
        <script>
            
            var SPEED = 0.01;
            var MODE = 0;
            var R_MIN = 10;
            var R_MAX = 100;
            var HUE_MIN = 0;
            var HUE_MAX = 360;
            var SAT_MIN = 40;
            var SAT_MAX = 40;
            var BRI_MIN = 100;
            var BRI_MAX = 100;
            var FREQ = 60; //Value between 0 and 100, logarithmicly controls spawn rate
            var ENABLE_ON_CLICK = true;
            
            var shapes = [];
            var spawnIntervalId;
            var canvases = [{
                hue: [45, 60],
                sat: [0, 0],
                bri: [20,80],
                poly: [
                    {x:0    ,y:0   },
                    {x:1920 ,y:0   },
                    {x:1920 ,y:1080},
                    {x:0    ,y:1080}
                ]
            },{
                hue: [0, 360],
                sat: [40, 40],
                bri: [100,100],
                img: {
                    url: "http://i.imgur.com/3FSu0pb.png",
                    x: 0,
                    y: 0
                }
            }];
            
            function preload() {
                for(var i = 0; i < canvases.length; i++) {
                    var c = canvases[i];
                    if(c.img) {
                        c.mask = loadImage(c.img);
                    }
                }
            }
            
            function setup() {
                createCanvas(windowWidth, windowHeight);
                for(var i = 0; i < canvases.length; i++) {
                    canvasI = canvases[i];
                    
                    if(canvasI.poly) {
                        canvasI.minX = canvasI.poly.reduce(
                            function(min, p){
                                return Math.min(min, p.x)
                            }, 0
                        );
                        canvasI.width = canvasI.poly.reduce(
                            function(max, p){
                                return Math.max(max, p.x)
                            }, 0
                        ) - canvasI.minX;
                        canvasI.minY = canvasI.poly.reduce(
                            function(min, p){
                                return Math.min(min, p.y)
                            }, 0
                        );
                        canvasI.height = canvasI.poly.reduce(
                            function(max, p){
                                return Math.max(max, p.y)
                            }, 0
                        ) - canvasI.minY;
                        
                        var g = createGraphics(canvasI.width, canvasI.height)
                        g.fill(0);
                        g.noStroke();
                        g.beginShape();
                        for(var j = 0; j < canvasI.poly.length; j++) {
                            g.vertex(canvasI.poly[j].x - canvasI.minX, canvasI.poly[j].y - canvasI.minY);
                        }
                        g.endShape();
                        canvasI.mask = g.get();
                    }else if(canvasI.img) {
                        canvasI.minX = 0;
                        canvasI.minY = 0;
                        canvasI.width = canvasI.mask.width;
                        canvasI.height = canvasI.mask.height;
                    }
                    canvasI.graphics = createGraphics(canvasI.width, canvasI.height)
                }
                resetSpawnInterval();
            }
            
            function draw() {
                for(var i = 0; i < shapes.length; i++) {
                    var shape = shapes[i];
                    shapes[i].draw();
                    if(shape.currentPercent >= 1) {
                        shapes.splice(i, 1)
                    }
                }
                for(var i = 0; i < canvases.length; i++) {
                    var c = canvases[i];
                    var img = c.graphics.get();
                    img.mask(c.mask);
                    image(img, c.minX, c.minY)
                }
            }
            
            function mouseClicked() {
                if(ENABLE_ON_CLICK) {
                    var shape = new Shape();
                    shape.x = mouseX;
                    shape.y = mouseY;
                    shapes[shapes.length] = shape;
                }
            }
            
            function windowResized() {
                resizeCanvas(windowWidth, windowHeight);
                resetSpawnInterval();
            }
            
            function Shape() {
                this.colors = [];
                this.currentPercent = 0;
                this.bezierPoints = [[0,0,.5,1],[0,0.6,1,1]]
                
                for(var i = 0; i < canvases.length; i++) {
                    this.colors[i] = generateColor(canvases[i]);
                }
                
                switch(MODE) {
                    case 0:
                        this.x = random(width);
                        this.y = random(height);
                        this.r = random(R_MIN, R_MAX)
                        break;
                }
                
                this.draw = function() {
                    if(this.currentPercent < 1) {
                        this.currentPercent += SPEED;
                        this._draw(this._mapPercent(this.currentPercent));
                    }
                }
                
                this._draw = function(mappedPercent) {
                    for(var i = 0; i < canvases.length; i++) {
                        var c = canvases[i];
                        var g = c.graphics;
                        var color = this.colors[i];
                        switch(MODE) {
                            case 0:
                                    g.fill(color)
                                    g.noStroke();
                                    g.ellipse(this.x - c.minX, this.y - c.minY, mappedPercent * 2 * this.r);
                                    break;
                        }
                    }
                }
            
                this._mapPercent = function(x) {
                    return calcBezier(invBezier(x, 0.0001, this.bezierPoints[0]),this.bezierPoints[1])
                }
                
            }
            
            function generateColor(canvas) {
                colorMode(HSB,360,100,100);
                var hue = random(canvas.hue[0],canvas.hue[1])%360;
                hue = hue<0?hue+360:hue;
                return color(
                    hue,
                    random(canvas.sat[0],canvas.sat[1])%360,
                    random(canvas.bri[0],canvas.bri[1])%360
                )
            }
            
            function calcBezier(t, points) {
                if(points.length === 1) {
                    return points[0];
                }else if(points.length < 1) {
                    throw new Error("Illegal Argument:  Bezier curves need at least one point");
                }else {
                    return (1-t) * calcBezier(t, points.slice(0, points.length - 1)) + t * calcBezier(t, points.slice(1, points.length));
                }
            }
            
            function invBezier(x, tol, points) {
                var min = 0;
                var max = 1;
                while(Math.abs(min-max) > tol) {
                    var index = (min + max)/2;
                    var atIndex = calcBezier(index, points);
                    if(atIndex > x) {
                        max = index;
                    }else if(atIndex < x) {
                        min = index;
                    }else{//Yeah, right
                        return index;
                    }
                }
                return (min + max)/2
            }
            
            function resetSpawnInterval() {
                if(spawnIntervalId)
                    clearInterval(spawnIntervalId);
                
                if(FREQ) {
                    spawnIntervalId = setInterval(function() {
                        if(shapes.length < 100)
                            shapes[shapes.length] = new Shape();
                    }, 1e3/(Math.pow(3.7,FREQ/10)*1e-9*width*height + 3e-3));
                }
            }
            
            wallpaperPropertyListener = {
                applyUserProperties: function(props) {
                    if(props.hueMin) {
                        HUE_MIN = props.hueMin.value;
                    }
                    if(props.hueMax) {
                        HUE_MAX = props.hueMax.value;
                    }
                    if(props.satMin) {
                        SAT_MIN = props.satMin.value;
                    }
                    if(props.satMax) {
                        SAT_MAX = props.satMax.value;
                    }
                    if(props.briMin) {
                        BRI_MIN = props.briMin.value;
                    }
                    if(props.briMax) {
                        BRI_MAX = props.briMax.value;
                    }
                    if(props.freq) {
                        FREQ = props.freq.value;
                        resetSpawnInterval();
                    }
                    if(props.enableOnClick) {
                        ENABLE_ON_CLICK = props.enableOnClick.value;
                    }
                    if(props.speed) {
                        SPEED = props.speed.value/1000;
                    }
                }
            }
            
        </script>
    </body>
</html>